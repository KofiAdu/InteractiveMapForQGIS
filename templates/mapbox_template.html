<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Mapbox Export</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <link href="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.css" rel="stylesheet" />
    <style>
      html, body, #map { height: 100%; margin: 0; }
      .ui { position: absolute; top: 10px; right: 10px; z-index: 10; display: flex; gap: 10px; }
      .panel {
        background: #fff; padding: 10px 12px; border-radius: 10px; box-shadow: 0 2px 12px rgba(0,0,0,.25);
        font: 12px/1.2 system-ui, sans-serif; max-height: 60vh; overflow: auto;
      }
      .panel h4 { margin: 0 0 8px; font-size: 12px; }
      .panel label { display: flex; align-items: center; gap: 6px; margin: 4px 0; }
      .popup { font: 12px/1.3 system-ui, sans-serif; }
      .popup hr { border: none; border-top: 1px solid #eee; margin: 6px 0; }
      .swatch {
        width: 12px; height: 12px; border-radius: 2px;
        border: 1px solid rgba(0,0,0,.25);
        box-shadow: inset 0 0 0 1px rgba(255,255,255,.4);
        flex: 0 0 auto;
      }
      .panel label.dim { opacity: 0.45; }
    </style>

    {{PRELOAD_SCRIPTS}}
  </head>
  <body>
    <div id="map"></div>

    <script src="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.js"></script>
    <script>
      (() => {
        mapboxgl.accessToken = "{{MAPBOX_TOKEN}}";

        const styleUrl = "{{MAPBOX_STYLE}}";
        const hasStyle = styleUrl && !styleUrl.includes("{{");

        const map = new mapboxgl.Map({
          container: "map",
          style: hasStyle ? styleUrl : { version: 8, sources: {}, layers: [] },
          center: [0, 0],
          zoom: 2,
          pitch: hasStyle ? 45 : 0,
          bearing: hasStyle ? -17.6 : 0,
        });

        let HIT_IDS = [];
        let HANDLERS_BOUND = false;

        function firstOverlayId() {
          const layers = map.getStyle().layers || [];
          const first = layers.find((l) => l.id !== "basemap");
          return first ? first.id : undefined;
        }
        function ensureBasemapBelowOverlays() {
          if (!map.getLayer("basemap")) return;
          const beforeId = firstOverlayId();
          if (beforeId) map.moveLayer("basemap", beforeId);
        }

        function firstLabelLayerId() {
          const layers = map.getStyle().layers || [];
          for (const l of layers) {
            if (l.type === 'symbol' && l.layout && l.layout['text-field']) return l.id;
          }
          return undefined;
        }

        function isLonLatBounds(b) {
          if (!Array.isArray(b) || b.length !== 4) return false;
          const [minx, miny, maxx, maxy] = b.map(Number);
          return (
            Number.isFinite(minx) && Number.isFinite(miny) &&
            Number.isFinite(maxx) && Number.isFinite(maxy) &&
            minx >= -180 && maxx <= 180 && miny >= -90 && maxy <= 90 &&
            minx <= maxx && miny <= maxy
          );
        }
        function bboxFromGeoJSON(gj) {
          const fc = (gj?.type === "FeatureCollection") ? gj :
                     (gj?.type === "Feature") ? { type:"FeatureCollection", features:[gj] } :
                     { type:"FeatureCollection", features:[] };
          let minx=Infinity, miny=Infinity, maxx=-Infinity, maxy=-Infinity;
          const walk = (c) => {
            if (!Array.isArray(c)) return;
            if (typeof c[0] === "number" && typeof c[1] === "number") {
              const x=c[0], y=c[1];
              if (Number.isFinite(x) && Number.isFinite(y)) {
                if (x<minx) minx=x; if (y<miny) miny=y;
                if (x>maxx) maxx=x; if (y>maxy) maxy=y;
              }
            } else { for (const ci of c) walk(ci); }
          };
          for (const f of fc.features) {
            const g = f?.geometry; if (!g) continue;
            if (g.type === "GeometryCollection") (g.geometries||[]).forEach(gg => walk(gg.coordinates));
            else walk(g.coordinates);
          }
          if (minx === Infinity) return null;
          const out = [minx,miny,maxx,maxy];
          return isLonLatBounds(out) ? out : null;
        }

        const ui = document.createElement("div");
        ui.className = "ui";
        const overlayPanel = document.createElement("div");
        overlayPanel.className = "panel";
        overlayPanel.innerHTML = "<h4>Layers</h4>";
        ui.appendChild(overlayPanel);

        if (!hasStyle) {
          const basePanel = document.createElement("div");
          basePanel.className = "panel";
          basePanel.innerHTML = "<h4>Basemap</h4>";

          const choices = [
            { name: "Selected (default)", url: "{{BASEMAP_URL}}" },
            { name: "OpenStreetMap", url: "https://tile.openstreetmap.org/{z}/{x}/{y}.png" },
          ];

          function addRasterBasemap(url) {
            if (map.getLayer("basemap")) map.removeLayer("basemap");
            if (map.getSource("basemap")) map.removeSource("basemap");
            map.addSource("basemap", { type: "raster", tiles: [url], tileSize: 256 });
            map.addLayer({ id: "basemap", type: "raster", source: "basemap" });
            ensureBasemapBelowOverlays();
          }

          choices.forEach((bm, i) => {
            const row = document.createElement("label");
            const rb = document.createElement("input");
            rb.type = "radio";
            rb.name = "basemap";
            rb.checked = i === 0;
            rb.onchange = () => { if (rb.checked) addRasterBasemap(bm.url); };
            row.appendChild(rb);
            row.appendChild(document.createTextNode(bm.name));
            basePanel.appendChild(row);
          });

          ui.appendChild(basePanel);
          map.on("load", () => addRasterBasemap(choices[0].url));
        } else {
          const vpanel = document.createElement("div");
          vpanel.className = "panel";
          vpanel.innerHTML = "<h4>Basemap (3D)</h4>";

          const vectorStyles = [
            { name: "Standard",  url: "mapbox://styles/mapbox/standard" },
            { name: "Streets",   url: "mapbox://styles/mapbox/streets-v11" },
            { name: "Light",     url: "mapbox://styles/mapbox/light-v10" },
            { name: "Dark",      url: "mapbox://styles/mapbox/dark-v10" },
            { name: "Satellite", url: "mapbox://styles/mapbox/satellite-v9" }
          ];
          if (styleUrl && !vectorStyles.some(s => s.url === styleUrl)) {
            vectorStyles.unshift({ name: "Selected (current)", url: styleUrl });
          }

          vectorStyles.forEach((s, i) => {
            const row = document.createElement("label");
            const rb  = document.createElement("input");
            rb.type = "radio"; rb.name = "vbasemap";
            rb.checked = (s.url === styleUrl) || (i === 0 && !styleUrl);
            rb.onchange = () => { if (rb.checked) switchVectorStyle(s.url); };
            row.appendChild(rb);
            row.appendChild(document.createTextNode(s.name));
            vpanel.appendChild(row);
          });

          ui.appendChild(vpanel);
        }

        document.body.appendChild(ui);

        const hue = (i) => (i * 137.508) % 360;
        const fillColor   = (i) => `hsla(${hue(i)},70%,55%,0.35)`;
        const strokeColor = (i) => `hsl(${hue(i)},70%,35%)`;
        const pointColor  = (i) => `hsl(${hue(i)},70%,55%)`;

        const getManifest = window.__manifest
          ? Promise.resolve(window.__manifest)
          : fetch("{{MANIFEST_URL}}").then(r => r.json()).catch(() => ({ layers: [] }));

        const popup = new mapboxgl.Popup({
          closeButton: true,
          closeOnClick: false,
          className: "popup",
        });

        function bindPopupsAndCursor(layerIds) {
          layerIds.forEach(id => {
            if (!map.getLayer(id)) return;
            map.on("mouseenter", id, () => map.getCanvas().style.cursor = "pointer");
            map.on("mouseleave", id, () => map.getCanvas().style.cursor = "");
            map.on("click", id, (e) => {
              const f = e.features?.[0];
              const props = f?.properties || {};
              const keys = Object.keys(props);
              if (!keys.length) { popup.remove(); return; }
              const rows = keys.map(k => `<div><b>${escapeHtml(k)}:</b> ${formatVal(props[k])}</div>`).join("");
              popup.setLngLat(e.lngLat).setHTML(rows).addTo(map);
            });
          });
        }

        function bindPointerHandlersOnce() {
          if (HANDLERS_BOUND) return;
          HANDLERS_BOUND = true;
          map.on("mousemove", (e) => {
            const pad = 5;
            const box = [[e.point.x - pad, e.point.y - pad],[e.point.x + pad, e.point.y + pad]];
            const feats = HIT_IDS.length ? map.queryRenderedFeatures(box, { layers: HIT_IDS }) : [];
            map.getCanvas().style.cursor = feats.length ? "pointer" : "";
          });
          map.on("click", (e) => {
            const pad = 10;
            const box = [[e.point.x - pad, e.point.y - pad],[e.point.x + pad, e.point.y + pad]];
            let feats = HIT_IDS.length ? map.queryRenderedFeatures(box, { layers: HIT_IDS }) : [];
            feats = dedupe(feats);
            if (!feats.length) { popup.remove(); return; }
            let html = "";
            feats.slice(0, 10).forEach((f) => {
              const props = f.properties || {};
              const keys = Object.keys(props);
              if (!keys.length) return;
              const rows = keys.map((k) => `<div><b>${escapeHtml(k)}:</b> ${formatVal(props[k])}</div>`);
              if (rows.length) { if (html) html += "<hr/>"; html += rows.join(""); }
            });
            html ? popup.setLngLat(e.lngLat).setHTML(html).addTo(map) : popup.remove();
          });
        }
        bindPointerHandlersOnce();

        map.on("load", async () => {
          if (hasStyle) ensureTerrain();
          await buildOverlays();
        });

        async function buildOverlays() {
          const man = await getManifest;
          const layers = Array.isArray(man.layers) ? man.layers : [];
          const overlayIds = [];
          const hitIds = [];
          let bounds;
          overlayPanel.innerHTML = "<h4>Layers</h4>";

          for (let i = 0; i < layers.length; i++) {
            const lyr = layers[i];
            const kind  = (lyr.geometryKind || "").toLowerCase();
            const gtype = (lyr.geometryType || "").toLowerCase();
            const isPoint = kind === "point" || gtype.includes("point");
            const isLine  = kind === "line"  || gtype.includes("line");

            const key = lyr.key || `layer-${i}`;
            const srcId = `${key}-src-${i}`;
            const baseId = `${key}-lyr-${i}`;

            const gj = await loadGeoJSON(lyr);
            if (!gj) { console.warn("Layer data missing:", key, lyr.path); continue; }

            if (map.getSource(srcId)) map.removeSource(srcId);
            map.addSource(srcId, { type: "geojson", data: gj, generateId: true });

            const beforeId = firstLabelLayerId();

            const ptsId = `${baseId}-pts`;
            const lnId  = `${baseId}-line`;
            const plId  = `${baseId}-fill`;

            if (map.getLayer(ptsId)) map.removeLayer(ptsId);
            map.addLayer({
              id: ptsId, type: "circle", source: srcId,
              filter: ["match", ["geometry-type"], ["Point","MultiPoint"], true, false],
              paint: {
                "circle-radius": 5,
                "circle-color": pointColor(i),
                "circle-stroke-color": strokeColor(i),
                "circle-stroke-width": 1
              }
            }, beforeId);

            if (map.getLayer(lnId)) map.removeLayer(lnId);
            map.addLayer({
              id: lnId, type: "line", source: srcId,
              filter: ["match", ["geometry-type"], ["LineString","MultiLineString"], true, false],
              paint: { "line-width": 1.5, "line-color": strokeColor(i) }
            }, beforeId);

            if (map.getLayer(plId)) map.removeLayer(plId);
            map.addLayer({
              id: plId, type: "fill", source: srcId,
              filter: ["match", ["geometry-type"], ["Polygon","MultiPolygon"], true, false],
              paint: { "fill-color": fillColor(i), "fill-outline-color": strokeColor(i) }
            }, beforeId);

            [ptsId, lnId, plId].forEach(id => {
              try { map.setLayoutProperty(id, "visibility", "visible"); } catch {}
              hitIds.push(id);
              overlayIds.push(id);
            });

            // bind popups directly on these layers
            bindPopupsAndCursor([ptsId, lnId, plId]);

            // UI row (visual swatch only)
            const row = document.createElement("label");
            const cb  = document.createElement("input");
            cb.type = "checkbox";
            cb.checked = true;

            const sw = document.createElement("span");
            sw.className = "swatch";
            if (isPoint) {
              sw.style.backgroundColor = pointColor(i);
              sw.style.borderColor     = strokeColor(i);
            } else if (isLine) {
              sw.style.backgroundColor = strokeColor(i);
              sw.style.borderColor     = strokeColor(i);
            } else {
              sw.style.backgroundColor = fillColor(i);
              sw.style.borderColor     = strokeColor(i);
            }

            cb.onchange = () => {
              (map.getStyle().layers || []).forEach(l => {
                if (l.id.startsWith(baseId)) {
                  map.setLayoutProperty(l.id, "visibility", cb.checked ? "visible" : "none");
                }
              });
              row.classList.toggle("dim", !cb.checked);
            };

            row.appendChild(cb);
            row.appendChild(sw);
            row.appendChild(document.createTextNode(lyr.label || lyr.name || key));
            row.classList.remove("dim");
            overlayPanel.appendChild(row);

            let bArr = isLonLatBounds(lyr.bounds) ? lyr.bounds : bboxFromGeoJSON(gj);
            if (bArr) {
              const [minx, miny, maxx, maxy] = bArr;
              const b = new mapboxgl.LngLatBounds([minx, miny], [maxx, maxy]);
              bounds = bounds ? bounds.extend(b) : b;
            }
          }

          try {
            if (bounds && !bounds.isEmpty()) {
              map.fitBounds(bounds, { padding: 20, duration: 0 });
            }
          } catch (e) {
            console.warn("fitBounds skipped:", e);
          }

          HIT_IDS = hitIds;
          console.log("Hit layers:", HIT_IDS);
        }

        function ensureTerrain() {
          if (map.getTerrain()) return;
          if (!map.getSource("mapbox-dem")) {
            map.addSource("mapbox-dem", {
              type: "raster-dem",
              url: "mapbox://mapbox.mapbox-terrain-dem-v1",
              tileSize: 512
            });
          }
          map.setTerrain({ source: "mapbox-dem", exaggeration: 1.0 });
          if (!map.getLayer("sky")) {
            map.addLayer({
              id: "sky", type: "sky",
              paint: { "sky-type": "atmosphere", "sky-atmosphere-sun-intensity": 15 }
            });
          }
        }

        // helpers
        async function loadGeoJSON(lyr) {
          if (lyr && lyr.path) {
            try {
              const resp = await fetch(
                lyr.path + (lyr.path.includes("?") ? "&" : "?") + "t=" + Date.now(),
                { cache: "no-store" }
              );
              if (resp.ok) {
                const gj = await resp.json();
                if (gj && (gj.type === "FeatureCollection" || gj.type === "Feature")) return gj;
              }
            } catch (e) {
              // fetch failed (likely file://). fall back to preloaded
            }
          }
          const key = lyr && lyr.key;
          return (window.__layers && key && window.__layers[key]) || null;
        }

        function formatVal(v) {
          if (v == null) return "";
          if (typeof v === "object") {
            try { return escapeHtml(JSON.stringify(v)); } catch { return String(v); }
          }
          return escapeHtml(String(v));
        }
        function escapeHtml(s) {
          return String(s).replace(/[&<>"']/g, (c) => ({
            "&":"&amp;", "<":"&lt;", ">":"&gt;", '"':"&quot;", "'":"&#39;"
          }[c]));
        }
        function dedupe(features) {
          const seen = new Set(), out = [];
          for (const f of features) {
            const base = f.id != null ? `id:${f.id}` : `p:${JSON.stringify(f.properties||{})}`;
            const key  = `${f.source}:${base}`;
            if (seen.has(key)) continue;
            seen.add(key);
            out.push(f);
          }
          return out;
        }

        function switchVectorStyle(newUrl) {
          const center  = map.getCenter();
          const zoom    = map.getZoom();
          const pitch   = map.getPitch();
          const bearing = map.getBearing();

          map.setStyle(newUrl, { diff: false });
          map.once("style.load", async () => {
            map.jumpTo({ center, zoom, pitch, bearing });
            ensureTerrain();
            await buildOverlays();    
          });
        }
      })();
    </script>
  </body>
</html>
