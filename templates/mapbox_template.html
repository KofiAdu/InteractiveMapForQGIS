<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mapbox Export</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>

  <link href="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.css" rel="stylesheet">
  <style>
    html, body, #map { height:100%; margin:0; }
    .ui { position:absolute; top:10px; right:10px; z-index:10; display:flex; gap:10px; }
    .panel { background:#fff; padding:10px 12px; border-radius:10px; box-shadow:0 2px 12px rgba(0,0,0,.25);
             font:12px/1.2 system-ui,sans-serif; max-height:60vh; overflow:auto; }
    .panel h4 { margin:0 0 8px; font-size:12px; }
    .panel label { display:flex; align-items:center; gap:6px; margin:4px 0; }
    .popup { font:12px/1.3 system-ui,sans-serif; }
    .popup hr { border:none; border-top:1px solid #eee; margin:6px 0; }

    .swatch{
      width:12px; height:12px; border-radius:2px;
      border:1px solid rgba(0,0,0,.25);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.4);
      flex:0 0 auto;
    }
    .panel label.dim { opacity:.45; }
  </style>

  {{PRELOAD_SCRIPTS}}
</head>
<body>
<div id="map"></div>

<script src="https://api.mapbox.com/mapbox-gl-js/v3.5.1/mapbox-gl.js"></script>
<script>
(() => {
  mapboxgl.accessToken = '{{MAPBOX_TOKEN}}';

  const styleUrl = '{{MAPBOX_STYLE}}';
  const hasStyle = styleUrl && !styleUrl.includes('{{');

  const map = new mapboxgl.Map({
    container: 'map',
    style: hasStyle ? styleUrl : { version: 8, sources: {}, layers: [] },
    center: [0,0],
    zoom: 2,
    pitch: hasStyle ? 45 : 0,
    bearing: hasStyle ? -17.6 : 0
  });

  function firstOverlayId() {
    const layers = map.getStyle().layers || [];
    const first = layers.find(l => l.id !== 'basemap');
    return first ? first.id : undefined;
  }
  function ensureBasemapBelowOverlays() {
    if (!map.getLayer('basemap')) return;
    const beforeId = firstOverlayId();
    if (beforeId) map.moveLayer('basemap', beforeId);
  }

  const ui = document.createElement('div'); ui.className = 'ui';
  const overlayPanel = document.createElement('div'); overlayPanel.className = 'panel'; overlayPanel.innerHTML = '<h4>Layers</h4>';
  ui.appendChild(overlayPanel);

  if (!hasStyle) {
    const basePanel = document.createElement('div'); basePanel.className = 'panel'; basePanel.innerHTML = '<h4>Basemap</h4>';

    const choices = [
      { name: 'Selected (default)', url: '{{BASEMAP_URL}}' },
      { name: 'OpenStreetMap', url: 'https://tile.openstreetmap.org/{z}/{x}/{y}.png' },
    ];

    function addRasterBasemap(url) {
      if (map.getLayer('basemap')) map.removeLayer('basemap');
      if (map.getSource('basemap')) map.removeSource('basemap');
      map.addSource('basemap', { type: 'raster', tiles: [url], tileSize: 256 });
      map.addLayer({ id: 'basemap', type: 'raster', source: 'basemap' });
      ensureBasemapBelowOverlays(); 
    }

    choices.forEach((bm, i) => {
      const row = document.createElement('label');
      const rb  = document.createElement('input'); rb.type = 'radio'; rb.name = 'basemap';
      rb.checked = i === 0;
      rb.onchange = () => { if (rb.checked) addRasterBasemap(bm.url); };
      row.appendChild(rb); row.appendChild(document.createTextNode(bm.name));
      basePanel.appendChild(row);
    });

    ui.appendChild(basePanel);
    map.on('load', () => addRasterBasemap(choices[0].url)); 
  } else {
    const vpanel = document.createElement('div'); 
    vpanel.className = 'panel';
    vpanel.innerHTML = '<h4>Basemap (3D)</h4>';

    const vectorStyles = [
      { name: 'Standard',  url: 'mapbox://styles/mapbox/standard' },
      { name: 'Streets',   url: 'mapbox://styles/mapbox/streets-v11' },
      { name: 'Light',     url: 'mapbox://styles/mapbox/light-v10' },
      { name: 'Dark',      url: 'mapbox://styles/mapbox/dark-v10' },
      { name: 'Satellite', url: 'mapbox://styles/mapbox/satellite-v9' }
    ];
    if (styleUrl && !vectorStyles.some(s => s.url === styleUrl)) {
      vectorStyles.unshift({ name: 'Selected (current)', url: styleUrl });
    }

    vectorStyles.forEach((s, i) => {
      const row = document.createElement('label');
      const rb  = document.createElement('input'); 
      rb.type = 'radio'; rb.name = 'vbasemap';
      rb.checked = (s.url === styleUrl) || (i === 0 && !styleUrl);
      rb.onchange = () => { if (rb.checked) switchVectorStyle(s.url); };
      row.appendChild(rb); row.appendChild(document.createTextNode(s.name));
      vpanel.appendChild(row);
    });

    ui.appendChild(vpanel);
  }

  document.body.appendChild(ui);

  const hue = i => (i * 137.508) % 360;
  const fillColor   = i => `hsla(${hue(i)},70%,55%,0.35)`;
  const strokeColor = i => `hsl(${hue(i)},70%,35%)`;
  const pointColor  = i => `hsl(${hue(i)},70%,55%)`;

  const getManifest = window.__manifest
    ? Promise.resolve(window.__manifest)
    : fetch('{{MANIFEST_URL}}').then(r => r.json()).catch(() => ({ layers: [] }));

  async function buildOverlays() {
    const man = await getManifest;
    const layers = Array.isArray(man.layers) ? man.layers : [];
    const overlayIds = []; 
    const hitIds = [];     
    let bounds;
    overlayPanel.innerHTML = '<h4>Layers</h4>';

    for (let i = 0; i < layers.length; i++) {
      const lyr = layers[i];
      const key = lyr.key || `layer-${i}`;
      const srcId = `${key}-src-${i}`;   
      const baseId = `${key}-lyr-${i}`;

      const gj = await loadGeoJSON(lyr);
      if (!gj) { console.warn('Layer data missing:', key, lyr.path); continue; }

      if (!map.getSource(srcId)) map.addSource(srcId, { type: 'geojson', data: gj });

      const gtype = (lyr.geometryType || '').toLowerCase();

      if (gtype.includes('point')) {
        const id = `${baseId}-circle`;
        map.addLayer({
          id, type: 'circle', source: srcId,
          paint: { 'circle-radius': 4, 'circle-color': pointColor(i), 'circle-stroke-color': strokeColor(i), 'circle-stroke-width': 1 }
        });
        map.setLayoutProperty(id, 'visibility', 'visible');
        overlayIds.push(id); hitIds.push(id);
        ensureBasemapBelowOverlays();
      } else if (gtype.includes('line')) {
        const id = `${baseId}-line`;
        map.addLayer({ id, type: 'line', source: srcId, paint: { 'line-width': 1.5, 'line-color': strokeColor(i) } });
        map.setLayoutProperty(id, 'visibility', 'visible');
        overlayIds.push(id); hitIds.push(id);
        ensureBasemapBelowOverlays();
      } else {
        const idFill = `${baseId}-fill`;
        const idLine = `${baseId}-outline`;
        map.addLayer({ id: idFill, type: 'fill', source: srcId, paint: { 'fill-color': fillColor(i), 'fill-outline-color': strokeColor(i) } });
        map.setLayoutProperty(idFill, 'visibility', 'visible');
        map.addLayer({ id: idLine, type: 'line', source: srcId, paint: { 'line-width': 1, 'line-color': strokeColor(i) } });
        map.setLayoutProperty(idLine, 'visibility', 'visible');
        overlayIds.push(idFill, idLine); hitIds.push(idFill);
        ensureBasemapBelowOverlays();
      }

      const row = document.createElement('label');           
      const cb  = document.createElement('input');          
      cb.type = 'checkbox';                                 
      cb.checked = true;                                    

      const sw = document.createElement('span');             
      sw.className = 'swatch';                               

      // Color the swatch to match how the layer is drawn                 
      if (gtype.includes('point')) {                                     
        sw.style.backgroundColor = pointColor(i);                        
        sw.style.borderColor     = strokeColor(i);                       
      } else if (gtype.includes('line')) {                               
        sw.style.backgroundColor = strokeColor(i);                       
        sw.style.borderColor     = strokeColor(i);                       
      } else {                                                           
        sw.style.backgroundColor = fillColor(i);                         
        sw.style.borderColor     = strokeColor(i);                       
      }                                                                  

      cb.onchange = () => {                                              
        map.getStyle().layers.forEach(l => {                             
          if (l.id.startsWith(baseId)) {                                 
            map.setLayoutProperty(l.id, 'visibility', cb.checked ? 'visible' : 'none'); 
          }                                                               
        });                                                               
        row.classList.toggle('dim', !cb.checked);                         
      };                                                                  

      row.appendChild(cb);                                                
      row.appendChild(sw);                                                
      row.appendChild(document.createTextNode(lyr.label || lyr.name || key)); 
      row.classList.remove('dim');                                        
      overlayPanel.appendChild(row);                                      

      if (lyr.bounds && lyr.bounds.length === 4) {
        const [minx, miny, maxx, maxy] = lyr.bounds;
        const b = new mapboxgl.LngLatBounds([minx, miny], [maxx, maxy]);
        bounds = bounds ? bounds.extend(b) : b;
      }
    }

    if (bounds) map.fitBounds(bounds, { padding: 20, duration: 0 });

    map.on('mousemove', (e) => {
      const pad = 5, box = [[e.point.x - pad, e.point.y - pad],[e.point.x + pad, e.point.y + pad]];
      const feats = map.queryRenderedFeatures(box, { layers: hitIds });
      map.getCanvas().style.cursor = feats.length ? 'pointer' : '';
    });

    map.on('click', (e) => {
      const pad = 6, box = [[e.point.x - pad, e.point.y - pad],[e.point.x + pad, e.point.y + pad]];
      let feats = map.queryRenderedFeatures(box, { layers: hitIds });
      feats = dedupe(feats);
      if (!feats.length) { popup.remove(); return; }
      let html = '';
      feats.slice(0, 10).forEach(f => {
        const props = f.properties || {};
        const rows = Object.keys(props).map(k => `<div><b>${escapeHtml(k)}:</b> ${formatVal(props[k])}</div>`);
        if (rows.length) { if (html) html += '<hr/>'; html += rows.join(''); }
      });
      html ? popup.setLngLat(e.lngLat).setHTML(html).addTo(map) : popup.remove();
    });
  }

  const popup = new mapboxgl.Popup({ closeButton: true, closeOnClick: false, className: 'popup' });

  map.on('load', async () => {
    if (hasStyle) ensureTerrain();
    await buildOverlays();
  });

  function ensureTerrain() {
    if (map.getTerrain()) return;
    if (!map.getSource('mapbox-dem')) {
      map.addSource('mapbox-dem', { type: 'raster-dem', url: 'mapbox://mapbox.mapbox-terrain-dem-v1', tileSize: 512 });
    }
    map.setTerrain({ source: 'mapbox-dem', exaggeration: 1.0 });
    if (!map.getLayer('sky')) {
      map.addLayer({ id: 'sky', type: 'sky', paint: { 'sky-type': 'atmosphere', 'sky-atmosphere-sun-intensity': 15 } });
    }
  }

  // helpers
  async function loadGeoJSON(lyr) {
    if (lyr && lyr.path) {
      try {
        const resp = await fetch(lyr.path + (lyr.path.includes('?') ? '&' : '?') + 't=' + Date.now(), { cache: 'no-store' });
        if (resp.ok) {
          const gj = await resp.json();
          if (gj && (gj.type === 'FeatureCollection' || gj.type === 'Feature')) return gj;
        }
      } catch (e) {
        // fetch failed (likely file://). fall back to preloaded
      }
    }
    const key = lyr && lyr.key;
    return (window.__layers && key && window.__layers[key]) || null;
  }

  function formatVal(v){ if(v==null) return ''; if(typeof v==='object'){try{return escapeHtml(JSON.stringify(v));}catch{return String(v);} } return escapeHtml(String(v)); }
  function escapeHtml(s){ return String(s).replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }
  function dedupe(features) {
    const seen = new Set(), out = [];
    for (const f of features) {
      const base = f.id != null ? `id:${f.id}` : `p:${JSON.stringify(f.properties||{})}`;
      const key = `${f.source}:${base}`;
      if (seen.has(key)) continue;
      seen.add(key);
      out.push(f);
    }
    return out;
  }

  function switchVectorStyle(newUrl) {
    const center  = map.getCenter();
    const zoom    = map.getZoom();
    const pitch   = map.getPitch();
    const bearing = map.getBearing();

    map.setStyle(newUrl, { diff: false });
    map.once('style.load', async () => {
      map.jumpTo({ center, zoom, pitch, bearing });
      ensureTerrain();
      await buildOverlays();
    });
  }
})();
</script>
</body>
</html>
